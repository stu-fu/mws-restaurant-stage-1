if('serviceWorker'in navigator){window.addEventListener('load',function(){navigator.serviceWorker.register('service-worker.js').then(function(registration){// Registration was successful
console.log('ServiceWorker registration successful with scope: ',registration.scope);},function(err){// registration failed :(
console.log('ServiceWorker registration failed: ',err);});});}
/**
 * Common database helper functions.
 */class DBHelper{/**
	 * Database URL.
	 * Change this to restaurants.json file location on your server.
	 */static get DATABASE_URL(){const port=1337;// Change this to your server port
return`http://localhost:${port}/restaurants`;}/**
	 * Fetch all restaurants.
	 */static fetchRestaurants(callback){// This works on all devices/browsers, and uses IndexedDBShim as a final fallback
let indexedDB=window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB||window.shimIndexedDB;let open=indexedDB.open("Restaurants",1);let restaurantList=[];// Create the schema
open.onupgradeneeded=function(){let db=open.result;let store=db.createObjectStore("RestaurantStore",{keyPath:"id"});var customerObjectStore;console.log('idb upgrade needed');fetch(DBHelper.DATABASE_URL).then(function(response){return response.json();}).then(function(restaurants){callback(null,restaurants);store.transaction.oncomplete=function(){customerObjectStore=db.transaction("RestaurantStore","readwrite").objectStore("RestaurantStore");restaurants.forEach(function(customer){customerObjectStore.add(customer);});};}).catch(function(){const error=`Request failed.`;callback(error,null);});};open.onsuccess=function(){// Start a new transaction
var db=open.result;var tx=db.transaction("RestaurantStore","readwrite");var store=tx.objectStore("RestaurantStore");console.log('idb success');store.openCursor().onsuccess=function(event){var cursor=event.target.result;if(cursor){restaurantList.push(cursor.value);cursor.continue();}else{callback(null,restaurantList);console.log('list',restaurantList);console.log('Entries all displayed.');}};// Close the db when the transaction is done
tx.oncomplete=function(){db.close();};};}/**
	 * Fetch a restaurant by its ID.
	 */static fetchRestaurantById(id,callback){// fetch all restaurants with proper error handling.
DBHelper.fetchRestaurants((error,restaurants)=>{if(error){callback(error,null);}else{const restaurant=restaurants.find(r=>r.id==id);if(restaurant){// Got the restaurant
callback(null,restaurant);}else{// Restaurant does not exist in the database
callback('Restaurant does not exist',null);}}});}/**
	 * Fetch restaurants by a cuisine type with proper error handling.
	 */static fetchRestaurantByCuisine(cuisine,callback){// Fetch all restaurants  with proper error handling
DBHelper.fetchRestaurants((error,restaurants)=>{if(error){callback(error,null);}else{// Filter restaurants to have only given cuisine type
const results=restaurants.filter(r=>r.cuisine_type==cuisine);callback(null,results);}});}/**
	 * Fetch restaurants by a neighborhood with proper error handling.
	 */static fetchRestaurantByNeighborhood(neighborhood,callback){// Fetch all restaurants
DBHelper.fetchRestaurants((error,restaurants)=>{if(error){callback(error,null);}else{// Filter restaurants to have only given neighborhood
const results=restaurants.filter(r=>r.neighborhood==neighborhood);callback(null,results);}});}/**
	 * Fetch restaurants by a cuisine and a neighborhood with proper error handling.
	 */static fetchRestaurantByCuisineAndNeighborhood(cuisine,neighborhood,callback){// Fetch all restaurants
DBHelper.fetchRestaurants((error,restaurants)=>{if(error){callback(error,null);}else{let results=restaurants;if(cuisine!='all'){// filter by cuisine
results=results.filter(r=>r.cuisine_type==cuisine);}if(neighborhood!='all'){// filter by neighborhood
results=results.filter(r=>r.neighborhood==neighborhood);}callback(null,results);}});}/**
	 * Fetch all neighborhoods with proper error handling.
	 */static fetchNeighborhoods(callback){// Fetch all restaurants
DBHelper.fetchRestaurants((error,restaurants)=>{if(error){callback(error,null);}else{// Get all neighborhoods from all restaurants
const neighborhoods=restaurants.map((v,i)=>restaurants[i].neighborhood);// Remove duplicates from neighborhoods
const uniqueNeighborhoods=neighborhoods.filter((v,i)=>neighborhoods.indexOf(v)==i);callback(null,uniqueNeighborhoods);}});}/**
	 * Fetch all cuisines with proper error handling.
	 */static fetchCuisines(callback){// Fetch all restaurants
DBHelper.fetchRestaurants((error,restaurants)=>{if(error){callback(error,null);}else{// Get all cuisines from all restaurants
const cuisines=restaurants.map((v,i)=>restaurants[i].cuisine_type);// Remove duplicates from cuisines
const uniqueCuisines=cuisines.filter((v,i)=>cuisines.indexOf(v)==i);callback(null,uniqueCuisines);}});}/**
	 * Restaurant page URL.
	 */static urlForRestaurant(restaurant){return`./restaurant.html?id=${restaurant.id}`;}/**
	 * Restaurant image URL.
	 */static imageUrlForRestaurant(restaurant){const img=`/img/min/${restaurant.photograph}.webp`;return img;}/**
	 * Map marker for a restaurant.
	 */static mapMarkerForRestaurant(restaurant,map){const marker=new google.maps.Marker({position:restaurant.latlng,title:restaurant.name,url:DBHelper.urlForRestaurant(restaurant),map:map,animation:google.maps.Animation.DROP});return marker;}}
let restaurants,neighborhoods,cuisines;var map;var markers=[];/**
 * Fetch neighborhoods and cuisines as soon as the page is loaded.
 */document.addEventListener('DOMContentLoaded',event=>{fetchNeighborhoods();fetchCuisines();});/**
 * Fetch all neighborhoods and set their HTML.
 */fetchNeighborhoods=()=>{DBHelper.fetchNeighborhoods((error,neighborhoods)=>{if(error){// Got an error
console.error(error);}else{self.neighborhoods=neighborhoods;fillNeighborhoodsHTML();}});console.log('neighbor loaded');};/**
 * Set neighborhoods HTML.
 */fillNeighborhoodsHTML=(neighborhoods=self.neighborhoods)=>{const select=document.getElementById('neighborhoods-select');neighborhoods.forEach(neighborhood=>{const option=document.createElement('option');option.innerHTML=neighborhood;option.value=neighborhood;select.append(option);});};/**
 * Fetch all cuisines and set their HTML.
 */fetchCuisines=()=>{DBHelper.fetchCuisines((error,cuisines)=>{if(error){// Got an error!
console.error(error);}else{self.cuisines=cuisines;fillCuisinesHTML();}});};/**
 * Set cuisines HTML.
 */fillCuisinesHTML=(cuisines=self.cuisines)=>{const select=document.getElementById('cuisines-select');cuisines.forEach(cuisine=>{const option=document.createElement('option');option.innerHTML=cuisine;option.value=cuisine;select.append(option);});};/**
 * Initialize Google map, called from HTML.
 */window.initMap=()=>{let loc={lat:40.722216,lng:-73.987501};self.map=new google.maps.Map(document.getElementById('map'),{zoom:12,center:loc,scrollwheel:false});updateRestaurants();};/**
 * Update page and map for current restaurants.
 */updateRestaurants=()=>{const cSelect=document.getElementById('cuisines-select');const nSelect=document.getElementById('neighborhoods-select');const cIndex=cSelect.selectedIndex;const nIndex=nSelect.selectedIndex;const cuisine=cSelect[cIndex].value;const neighborhood=nSelect[nIndex].value;DBHelper.fetchRestaurantByCuisineAndNeighborhood(cuisine,neighborhood,(error,restaurants)=>{if(error){// Got an error!
console.error(error);}else{resetRestaurants(restaurants);fillRestaurantsHTML();}});};/**
 * Clear current restaurants, their HTML and remove their map markers.
 */resetRestaurants=restaurants=>{// Remove all restaurants
self.restaurants=[];const ul=document.getElementById('restaurants-list');const noResults=document.getElementById('no-results');ul.innerHTML='';if(noResults){ul.parentNode.removeChild(noResults);}// Remove all map markers
self.markers.forEach(m=>m.setMap(null));self.markers=[];self.restaurants=restaurants;};/**
 * Create all restaurants HTML and add them to the webpage.
 */fillRestaurantsHTML=(restaurants=self.restaurants)=>{const ul=document.getElementById('restaurants-list');restaurants.forEach(restaurant=>{ul.append(createRestaurantHTML(restaurant));});if(restaurants.length===0){const p=document.createElement('p');p.setAttribute('id','no-results');const parent=ul.parentNode;p.innerHTML="Sorry! There are no results for that combination.";parent.insertBefore(p,ul);}addMarkersToMap();};/**
 * Create restaurant HTML.
 */createRestaurantHTML=restaurant=>{const li=document.createElement('li');const image=document.createElement('img');image.className='restaurant-img';image.setAttribute('alt','Picture of '+restaurant.name);image.src=DBHelper.imageUrlForRestaurant(restaurant);//image.setAttribute('srcset','test');
li.append(image);const content=document.createElement('div');content.setAttribute('class','restaurant-summary');const name=document.createElement('h3');name.innerHTML=restaurant.name;content.append(name);const neighborhood=document.createElement('p');neighborhood.innerHTML=restaurant.neighborhood;content.append(neighborhood);const address=document.createElement('p');address.innerHTML=restaurant.address;content.append(address);const more=document.createElement('a');const moreText=`View Details <span class="visually-hidden">about ${restaurant.name}</span>`;more.innerHTML=moreText;more.href=DBHelper.urlForRestaurant(restaurant);content.append(more);li.append(content);return li;};/**
 * Add markers for current restaurants to the map.
 */addMarkersToMap=(restaurants=self.restaurants)=>{restaurants.forEach(restaurant=>{// Add marker to the map
const marker=DBHelper.mapMarkerForRestaurant(restaurant,self.map);google.maps.event.addListener(marker,'click',()=>{window.location.href=marker.url;});self.markers.push(marker);});};